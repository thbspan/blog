# Redis Pipeline管道

不是服务端直接提供的技术，是客户端提供的



## Redis 消息交互

Redis客户端和服务端的交互过程如下

![img](Redis Pipeline管道.assets/1648204d4930cc08)

客户端将请求发给服务端，服务端处理完成后，再将响应回复给客户端。这个过程中需要花费一个来回的网络时间

如果连续执行多个命令，那就会花费多个来回的网络时间

![img](Redis Pipeline管道.assets/1648205b22725764)

客户端的执行流程可以简单概况为 `写->读-写->读`

现在如果我们调整读写顺序，改成写—写-读-读，这两个指令同样可以正常完成。

两个连续的写操作和两个连续的读操作总共只会花费一个网络来回，就好比连续的 write 操作合并了，连续的 read 操作也合并了一样

这就是管道操作的本质



## 深入理解管道本质

下面从网络协议的角度来分析管道的本质

网络请求交互图

![img](Redis Pipeline管道.assets/1657e7a5a0a24ce3)

注：NIC 网卡

上图就是一个完整的请求交互流程图。我用文字来仔细描述一遍：

1. 客户端进程调用`write`将消息写到操作系统内核为套接字分配的发送缓冲`send buffer`。
2. 客户端操作系统内核将发送缓冲的内容发送到网卡，网卡硬件将数据通过「网际路由」送到服务器的网卡。
3. 服务器操作系统内核将网卡的数据放到内核为套接字分配的接收缓冲`recv buffer`。
4. 服务器进程调用`read`从接收缓冲中取出消息进行处理。
5. 服务器进程调用`write`将响应消息写到内核为套接字分配的发送缓冲`send buffer`。
6. 服务器操作系统内核将发送缓冲的内容发送到网卡，网卡硬件将数据通过「网际路由」送到客户端的网卡。
7. 客户端操作系统内核将网卡的数据放到内核为套接字分配的接收缓冲`recv buffer`。
8. 客户端进程调用`read`从接收缓冲中取出消息返回给上层业务逻辑进行处理。
9. 结束。

其中步骤 5~8 和 1~4 是一样的，只不过方向是反过来的，一个是请求，一个是响应。

我们开始以为 `write` 操作是要等到对方收到消息才会返回，但实际上不是这样的。`write` 操作只负责将数据写到本地操作系统内核的发送缓冲然后就返回了。剩下的事交给操作系统内核异步将数据送到目标机器。但是如果发送缓冲满了，那么就需要等待缓冲空出空闲空间来，这个就是写操作 IO 操作的真正耗时。

我们开始以为 `read` 操作是从目标机器拉取数据，但实际上不是这样的。`read` 操作只负责将数据从本地操作系统内核的接收缓冲中取出来就了事了。但是如果缓冲是空的，那么就需要等待数据到来，这个就是读操作 IO 操作的真正耗时。

而对于管道来说，连续的`write`操作根本就没有耗时，之后第一个`read`操作会等待一个网络的来回开销，然后所有的响应消息就都已经回送到内核的读缓冲了，后续的 `read` 操作直接就可以从缓冲拿到结果，瞬间就返回了。

