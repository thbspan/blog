# redis 检索key

## keys

```shell
keys *
keys tes*
```



缺点:

- 一次性吐出所有满足条件的key
- 实现是遍历算法。复杂度是O(n)，如果实例中有千万级以上的 key，这个指令就会导致 Redis 服务卡顿，所有读写 Redis 的其它的指令都会被延后甚至会超时报错，因为 Redis 是单线程程序，顺序执行所有指令，其它指令必须等到当前的 keys 指令执行完了才可以继续



## scan

- 复杂度虽然也是 O(n)，但是它是通过游标分步进行的，不会阻塞线程;
- 提供 limit 参数，可以控制每次返回结果的最大条数，limit 只是一个 hint，返回的结果可多可少;
- 同 keys 一样，它也提供模式匹配功能;
- 服务器不需要为游标保存状态，游标的唯一状态就是 scan 返回给客户端的游标整数;
- **返回的结果可能会有重复，需要客户端去重复**，这点非常重要;
- 遍历的过程中如果有数据修改，改动后的数据能不能遍历到是不确定的
- 单次返回的结果是空的并不意味着遍历结束，而要看返回的游标值是否为零

## scan 遍历顺序

高位进位加法来遍历

![img](redis 检索key.assets/16469760d12e0cbd)

从动画中可以看出高位进位法从左边加，进位往右边移动，同普通加法正好相反。但是最终它们都会遍历所有的槽位并且没有重复。

## 大key扫描

```
redis-cli --bigkey -i 0.1
```

-i 休眠时间

上面这个指令每隔 100 条 scan 指令就会休眠 0.1s，ops 就不会剧烈抬升，但是扫描的时间会变长。

